// Generated by CoffeeScript 1.7.1
var Genetic, Solution;

Solution = (require('./sol')).Solution;
_ = require("underscore");
Genetic = (function() {
    function Genetic(SolType, totalPop, keepPop, crossover_rate, mutation_rate) {
        this.SolType = SolType;
        this.totalPop = totalPop != null ? totalPop : 100;
        this.keepPop = keepPop;
        this.mutation_rate = typeof mutation_rate === "undefined" ? 0.5 : mutation_rate;
        this.crossover_rate = typeof crossover_rate === "undefined" ? 0.5 : crossover_rate;
        this.pop = new Array;
        return;
    }

    Genetic.prototype.init = function() {
        var i, newSol, _i, _ref;
        for (var i = 0; i < this.totalPop; i++) {
            newSol = new this.SolType;
            newSol.random();
            newSol.gen = 0;
            this.pop.push(newSol);
        }
    };

    Genetic.prototype.sort = function(show_best) {
        this.pop.sort(function(a, b) {
            return b.fit - a.fit;
        });
        if( show_best === true){
            console.log("inside sort:" + this.pop[0].fit);
        }
    };

    Genetic.prototype.bestfit = function() {
        this.sort();
        return this.pop[0];
    };

    Genetic.prototype["eval"] = function() {
        var sol, _i, _len, _ref, _results;
        _ref = this.pop;
        _results = [];
        if( typeof Solution.prototype.pre_eval === "function"){
            Solution.prototype.pre_eval();
        }

        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sol = _ref[_i];
            _results.push(sol["eval"]());
        }
        return _results;
    };

    Genetic.prototype.random = function() {
        var rand;
        rand = Math.round((Math.random() * 100000) % (this.pop.length - 1));
        return this.pop[_.random(0, 1)];
    };

    Genetic.prototype.totalFit = function() {
        var ret, sol, _i, _len, _ref;
        ret = 0;
        _ref = this.pop;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sol = _ref[_i];
            ret += sol.fit;
        }
        return ret;
    };

    Genetic.prototype.rws = function(f) {
        var ptr, sol, _i, _len, _ref;
        if (f == null) {
            f = null;
        }
        if (f === null) {
            f = Math.round(Math.random() * 1000000) % this.totalFit();
        }
        if (f === -1) {
            f = Math.random();
        }
        ptr = 0;
        _ref = this.pop ;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sol = _ref[_i];
            if (ptr < f && ptr + sol.fit > f) {
                return sol;
            }
            ptr += sol.fit;
        }
        return this.pop[0];
    };

    Genetic.prototype.selectRWS = function(k) {
        var i, newPop, _i, _ref;
        if (k == null) {
            k = null;
        }
        this.sort();

        newPop = new Array;
        for (i = _i = 1, _ref = this.totalPop - this.keepPop; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            newPop.push(this.rws(k));
        }
        this.pop = newPop;
    };

    Genetic.prototype.selectRWS2 = function() {
        this.selectRWS(-1);
    };

    Genetic.prototype.selectSUS = function() {
        var f, i, newPop, ptrs, start, totalFit, _i, _j, _len, _ref;
        totalFit = this.totalFit();
        start = (Math.random() * 1000) % (totalFit / this.totalPop);
        ptrs = new Array;
        for (i = _i = 0, _ref = this.totalPop - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            ptrs.push(start + i * (totalFit / this.totalPop));
        }
        newPop = new Array;
        for (_j = 0, _len = ptrs.length - this.keepPop; _j < _len; _j++) {
            f = ptrs[_j];
            newPop.push(this.rws(f));
        }
        this.pop = newPop;
    };

    Genetic.prototype.run = function() {

        if( typeof Solution.prototype.pre_eval === "function"){
            Solution.prototype.pre_eval();
        }
        for ( var i = 0; i < this.pop.length ; i++) {
            sol = this.pop[i];
            sol["eval"]();
        }
        this.gen = 0;

        while (true) {
            if (this.end()) {
                this.gen--;
                return;
            }
            var needed = this.totalPop - this.keepPop;
                crossover_num = Math.round( needed * this.crossover_rate ),
                keep = crossover_num > 0 ? needed - crossover_num : needed,
                mutation_num = Math.round( needed * this.mutation_rate);
                // console.log(keep, mutation_num, crossover_num);
            /**
             * Nominate members from current generation for the next generation
             * @type {Array}
             */

         
            keptpop = new Array,
            npop = new Array;

            this.sort(false);
            /**
              * Best members to keep
              * @type {Array}
              */
            for (var i = 0; i < this.keepPop ; i++) {
                keptpop.push(this.pop[i]);
            }

            /**
             * Do the selection
             */
            if (this.select) {
                this.select(this.totalPop);
                if (this.pop.length !== (this.totalPop - this.keepPop)) {
                    throw "Select method failed";
                }
            } else {
                this.sort();
                oldPop = this.pop;
                this.pop = new Array;
                for (i = _o = 0, _ref2 = this.totalPop - 1; 0 <= _ref2 ? _o <= _ref2 : _o >= _ref2; i = 0 <= _ref2 ? ++_o : --_o) {
                    this.pop.push(oldPop[i]);
                }
                oldPop = null;
            }

            /**
             * Append best members back to  current population
             */
            for (var i = 0; i < this.keepPop ; i++) {
                var index = this.pop.length - i - 1;
                this.pop[index] = keptpop[i];
            }

            /**
             * Do crossover to generate rest of the members
             * @type {Array}
             */
            newPopC = new Array;
            for (var i = 0; i < crossover_num; i++) {
                newSol = new this.SolType;
                var rand1 = this.random(),
                    rand2 = this.random();
                newSol.crossOver(rand1, rand2);
                newSol.gen = this.gen;
                newPopC.push(newSol);
            }

            /**
             * Do the mutation
             */
             newPopM = new Array;
            for (var i = 0; i < mutation_num; i++ ) {
                newSol = this.random().mutate();
                newSol.gen = this.gen;
                newPopM.push(newSol);
            }
            

            /**
             * Evaluate solutions
             */
            if( typeof Solution.prototype.pre_eval === "function"){
                Solution.prototype.pre_eval();
            }
            for (var m = 0, len1 = newPopC.length; m < len1; m++) {
                sol = newPopC[m];
                sol["eval"]();
            }

            for (var m = 0, len2 = newPopM.length; m < len2; m++) {
                sol = newPopM[m];
                sol["eval"]();
            }
            
            /**
             * Put kept members back to next population
             * @type {Number}
             */
            this.pop = keptpop.concat(newPopC).concat(newPopM);

            this.gen++;
        }
    };

    return Genetic;

})();

exports.Genetic = Genetic;

exports.Solution = Solution;
