// Generated by CoffeeScript 1.7.1
var Genetic, Solution; 
Solution = (require('./sol')).Solution;
Genetic = (function() {
    function Genetic(SolType, totalPop, keepPop, crossover_rate, mutation_rate) {
        this.SolType = SolType;
        this.totalPop = totalPop != null ? totalPop : 100;
        this.keepPop = keepPop;
        this.mutation_rate = typeof mutation_rate === "undefined" ? 0.5 : mutation_rate;
        this.crossover_rate = typeof crossover_rate === "undefined" ? 0.5 : crossover_rate;
        this.pop = new Array;
        return;
    }

    Genetic.prototype.init = function() {
        var i, newSol, _i, _ref;
        for (var i = 0; i < this.totalPop; i++) {
            newSol = new this.SolType;
            newSol.random();
            newSol.gen = 0;
            this.pop.push(newSol);
        }
    };

    Genetic.prototype.sort = function(show_best) {
        this.pop.sort(function(a, b) {
            return b.fit - a.fit;
        });
        if( show_best === true){
            console.log("inside sort:" + this.pop[0].fit);
        }
    };

    Genetic.prototype.bestfit = function() {
        this.sort();
        return this.pop[0];
    };

    Genetic.prototype.bestfiness = function(){
        return Math.max.apply(Math, this.pop.map( function(member){
            return member.fit;
        }));
    }
    Genetic.prototype["eval"] = function() {
        var sol, _i, _len, _ref, _results;
        _ref = this.pop;
        _results = [];
        if( typeof Solution.prototype.pre_eval === "function"){
            Solution.prototype.pre_eval();
        }
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sol = _ref[_i];
            _results.push(sol["eval"]());
        }
        return _results;
    };

    Genetic.prototype.random = function() {
        var rand;
        rand = Math.round((Math.random() * 100000) % (this.pop.length - 1));
        return this.pop[rand];
    };

    Genetic.prototype.totalFit = function() {
        var ret, sol, _i, _len, _ref;
        ret = 0;
        _ref = this.pop;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sol = _ref[_i];
            ret += sol.fit;
        }
        return ret;
    };

    Genetic.prototype.rws = function(f) {
        var ptr, sol, _i, _len, _ref;
        if (f == null) {
            f = null;
        }
        if (f === null) {
            f = Math.round(Math.random() * 1000000) % this.totalFit();
        }
        if (f === -1) {
            f = Math.random();
        }
        ptr = 0;
        _ref = this.pop ;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            sol = _ref[_i];
            if (ptr < f && ptr + sol.fit > f) {
                return sol;
            }
            ptr += sol.fit;
        }
        return this.pop[0];
    };

    Genetic.prototype.selectRWS = function(k) {
        var i, newPop, _i, _ref;
        if (k == null) {
            k = null;
        }
        this.sort();

        newPop = new Array;
        for (i = _i = 1, _ref = this.totalPop - this.keepPop; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            newPop.push(this.rws(k));
        }
        this.pop = newPop;
    };

    Genetic.prototype.selectRWS2 = function() {
        this.selectRWS(-1);
    };

    Genetic.prototype.selectSUS = function() {
        var f, i, newPop, ptrs, start, totalFit, _i, _j, _len, _ref;
        totalFit = this.totalFit();
        start = (Math.random() * 1000) % (totalFit / this.totalPop);
        ptrs = new Array;
        for (i = _i = 0, _ref = this.totalPop - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            ptrs.push(start + i * (totalFit / this.totalPop));
        }
        newPop = new Array;
        for (_j = 0, _len = ptrs.length - this.keepPop; _j < _len; _j++) {
            f = ptrs[_j];
            newPop.push(this.rws(f));
        }
        this.pop = newPop;
    };

    Genetic.prototype.run = function() {

        this.gen = 0;

        var needed = this.totalPop - this.keepPop;
            crossover_num = Math.ceil( needed * this.crossover_rate ),
            mutation_num = Math.ceil( needed * this.mutation_rate ),
            keptpop = new Array;
        while (true) {
            if (this.end()) {
                this.gen--;
                return;
            }


            /**
              * Best members to keep
              * @type {Array}
              */
            this.sort();
            // for( k = 0; k < this.keepPop; k ++ ){
            //     keptpop.push(this.pop[k]);
            // }

            /**
             * Nominate members from current generation for the next generation
             * @type {Array}
             */
            keptpop = this.pop.slice(0, this.keepPop );
            /**
             * Do the selection
             */
            if (this.select) {
                this.select(this.totalPop);
                if (this.pop.length !== (this.totalPop - this.keepPop)) {
                    throw "Select method failed";
                }
            } else {
                this.sort();
                oldPop = this.pop;
                this.pop = new Array;
                for (i = _o = 0, _ref2 = this.totalPop - 1; 0 <= _ref2 ? _o <= _ref2 : _o >= _ref2; i = 0 <= _ref2 ? ++_o : --_o) {
                    this.pop.push(oldPop[i]);
                }
                oldPop = null;
            }


            /**
             * Do crossover to generate rest of the members
             * @type {Array}
             */
            var newPopC = new Array;
            for (var i = 0; i < crossover_num; i++) {
                var newSol = new this.SolType;
                var rand1 = this.random(),
                    rand2 = this.random();
                newSol.crossOver(rand1, rand2);
                newSol.gen = this.gen;
                newPopC.push(newSol);
            }
            this.pop = newPopC;
            // /**
            //  * Do the mutation
            //  */
             var newPopM = new Array;
            for (var i = 0; i < this.pop.length; i++ ) {
                if( Math.random() <= this.mutation_rate ){
                    var newSol = this.random().mutate();
                    newSol.gen = this.gen;
                    newPopM.push(newSol);
                }

            }

           

            /**
             * Put kept members back to next population
             * @type {Number}
             */
            //this.pop = keptpop;

            this.pop = this.pop.concat(newPopM).concat(keptpop);

            /**
             * Evaluate solutions
             */
            for (var m = 0, len2 = this.pop.length; m < len2; m++) {
                this.pop[m]["pre_eval"]();
                this.pop[m]["eval"]();
            }
 
            this.gen++;
        }
    };

    return Genetic;

})();

exports.Genetic = Genetic;

exports.Solution = Solution;
